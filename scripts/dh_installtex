#!/usr/bin/perl -w

=head1 NAME

dh_installtex - register Type 1 fonts, languages, or formats with TeX

=cut

use strict;
use Debian::Debhelper::Dh_Lib;

=head1 SYNOPSIS

B<dh_installtex>
[S<I<debhelper options>>]
[B<-n>]
[B<--priority=>I<n>]
[B<--flavor=>I<flavor>] 
[B<map=MixedMap,>I<file.map>]
[B<map=Map,>I<file.map>]
[B<mapfile=>I<file.cfg>[=I<n>]]
[B<language=>I<lang>,I<pattern>[,I<alternate>,...]]
[B<languagefile=>I<file.cnf>[=I<n>]]
[B<format=>I<format>,I<engine>,I<hyphenfile>,I<rest args>]
[B<formatfile=>I<file.cnf>[=I<n>]]
[B<texmftrees=>I<tree>[,I<tree>]]

=head1 DESCRIPTION

dh_installtex is a debhelper program that is responsible for
updating the ls-R databases, registering map files, new formats, 
and new hyphenation patterns with TeX.

Your package should depend on an appropriate version of tex-common so
that the update-* commands are available. (This program adds that
dependency to ${misc:Depends}.)

=head1 SIMPLE USAGE: Registering Files 

If you only install files into /usr/share/texmf and want to be sure that 
mktexlsr is called in a correct way (e.g., also
in the postrm script when there is no functional mktexlsr), simply call

	dh_installtex

The ls-R databases are [B<only>] updated for the following
trees: /usr/share/texmf and /var/lib/texmf. Normal TeX related packages
following the Debian TeX Policy should only install files into these 
directories and /etc/texmf (which does not need a ls-R DB), so this is
a sensible choice. If you need to rehash the ls-R database of some other
trees (eg. because an old package had files in /usr/share/texmf-tetex)
please specify these additional trees on the command line via the 
texmftrees option:

	dh_installtex texmftrees=tree1,tree2,...

This will update the ls-R databases for /usr/share/texmf, /var/lib/texmf, and
in addition tree1 and tree2.

=head1 COMPLEX USAGE: Registering fonts, hyphenation patterns and formats

If in addition you have to install map files, hyphenation patterns for
additional languages, or format definitions you can use three
different methods to specify what should be installed:

1) B<Pre made config files:> These files can be specified with the
different I<type>file= options, together with an optional priority.
I<type> can be one of map, format and language, and these files will be
installed into /etc/texmf/I<configdir>/ for the respective type (for
map files updmap.d, for language files language.d, and for format
files fmt.d).

Example:

        dh_installtex mapfile=foo.cfg formatfile=debian/bar.cnf=42

would install foo.cfg as /etc/texmf/updmap.d/10foo.cfg, and debian/bar.cnf
as /etc/texmf/fmt.d/42bar.cnf.


2) B<Directly on the cmd line:>
You can specify maps, formats, and languages on the cmd line. The items
are stored in the respective config file 10package

Example:

        dh_installtex map=Map,foo.map language=greek,grphyph4.tex,polygreek

would install a file /etc/texmf/updmap.d/10package.cfg containing the line

        Map foo.map

and a file /etc/texmf/language.d/10package.cnf containing the lines

	greek grphyph4.tex
	=polygreek

3) B<Package files:>
You create a file debian/package.maps or debian/maps,
debian/package.languages or debian/languages, 
debian/package.formats or debian/formats. These files are
installed with default priority and the name of the package. Each of these
files will be installed into the first package dh_installtex
is told to act on. By default this is the first binary package in
debian/control, but if you use -p, -i, or -a flags, it will be the first
package specified by those flags.

Example:

        dh_installtex

would install a present debian/package.maps file as
/etc/texmf/updmap.d/10package.cfg.


=head2 Mixing the different variants

The command line items (Variant 2) are merged into the debian/package.maps 
(debian/package.languages, debian/package.formats)
file and the merged file is installed as 10package.cfg/cnf. If you specify
an additional package.cfg/cnf (Variant 1) without a different priority than
the default one on the cmd line, this will raise an error since both files
would be installed as 10package.cfg/cnf. You can only specify 
package.cfg/cnf without
a different priority than the default one if no debian/package.maps nor
any command line Map files are present.

=head2 The pseudo-comment

If the provided cfg files do not contain the pseudo-comment as described
in the Debian TeX Policy, Font configuration, an additional header with
explanation, warning and the pseudo-comment is added.

This program automatically generates the postinst and postrm commands needed
to register the fonts with TeX.  See L<dh_installdeb(1)> for an explanation
of how this works.

=head1 OPTIONS

=over 4

=item B<-n>, B<--noscripts>

Do not modify postinst/prerm scripts.

=item B<--priority=>I<n>

Set the default priority to I<n> instead of 10.

=item B<--flavor=>I<flavor>

This option will be used to switch additional options on. At the moment
you can select for I<flavor> either B<map:config_for_active_maps> or
B<map:config_for_all_maps>.
B<map:config_for_active_maps> will create a file I<config.bar> for each active
(i.e. uncommented) map in each of the cfg file generated by one of the
three methods described above. These files are installed in
/usr/share/texmf/dvips/config/.

If you select B<map:config_for_all_maps> the script will generate I<config.bar>
even for those map files which are present in a cfg file, but deactivated by a comment.

The file I<config.bar> is used when called by `dvips -Pbar ...'. Thus it
allows the activation of single map files even if they are not automatically
activated via the updmap(-sys) mechanism.

Default is I<not> to generate any config files.

=head1 NOTES

Note that this command is not idempotent. "dh_clean -k" should be called
between invocations of this command, unless using the B<-n> option.
Otherwise, it may cause multiple instances of the same text to be added
to maintainer scripts.

Please refer to the Debian TeX policy for details about fonts configuration
for TeX by Debian packages.


=cut

init();



#
# GLOBAL VARIABLES
#
my $flavor;		
my $mapdoconfig =  0;	# doconfig depending map/subflavor
my $priority=10;	# priority with which files are installed
my $dothefullstuff = 0;
my %cmdlineargs;
my %cmdlinefiles;
my %cmdlinefilespriority;
my @cmdlinetexmftrees;

my @defaulttexmftrees = qw,/usr/share/texmf /var/lib/texmf,;
	
#
# definitions for the different flavors
#
# extension of package files debian/$package.formats and/or debian/formats etc
my %pkgfileext = ( 
	language	=> "languages", 
	format 		=> "formats", 
	map 		=> "maps" );
# extension of the config files
my %configfileext = ( 
	language 	=> "cnf", 
	format 		=> "cnf", 
	map 		=> "cfg" );
# comment char for magic header
my %commentchar = ( 
	language 	=> '%', 
	format 		=> '#', 
	map 		=> '#' );
# directory under /etc/texmf/ where files are installed
my %configdir = ( 
	language 	=> "language.d", 
	format 		=> "fmt.d", 
	map 		=> "updmap.d" );
# directory under /var/lib/tex-common where list files are installed
my %managedir = ( 
	language 	=> "language-cnf", 
	format 		=> "fmtutil-cnf", 
	map 		=> "fontmap-cfg" );
#
# dummy loop variables
my $i;
my $bn;
my $pr;
my $dofilen;

# the magic header without comment chars
my @magicheader = ( "You can change/add entries to this file and changes will be preserved", 
"over upgrades, even if you have removed the main package prior",
"(not if you purged it). You should leave the following pseudo comment",
"present in the file!",
"-_- DebPkgProvidedMaps -_-", "");

#
# collect data
# This function is used to extract certain information from the respective
# config files. Up to now we have to do the following:
# for config file for maps
# 	if we select to generate all dvips config files
# 	(with map:config_for_active_maps or map:config_for_all_maps)
# 	we collect the map files
# for config file for formats
# 	we extract the formats which have to be generated with
# 	fmtutil-sys --byfmt
sub collect_data {
	my ($type,$dataref,$entry) = @_;
	my $m;

	if ($type eq "map") {
		if ($m = extract_map($entry, $mapdoconfig)) { push @$dataref, $m; }
	} elsif ($type eq "format") {
		if ($m = extract_format($entry)) { push @$dataref, $m; }
	}
}

sub extract_format {
	my ($line) = @_;
	if ($line =~ m/^([^#\s]\S*)/) {
		return $1;
	}
}

sub extract_map {
	my ($line,$mapdoconfig) = @_;
	if ($mapdoconfig == 0) { return ""; }
	if ($line =~ m/^[[:space:]]*([#[:space:]]*)[[:space:]]*(Mixed)?Map[[:space:]]*(.*\.map)[[:space:]]*(#.*)?$/) {
		my $comment = $1;
		my $map = $3;
		if (($comment eq "") || ($mapdoconfig == 2)) {
			return $map;
		}
	}
	return "";
}

#
# build_line
# used to create a correct config file entry from a cmd-line specification
sub build_line {
	my ($type,$line) = @_;
	if ($type eq "map") {
		if ($line =~ m/^(Map|MixedMap),(.*)$/) {
			return("$1 $2");
		} else {
			error("$line is neither of the form Map,filename.map, MixedMap,filename.map.");
		}
	} elsif ($type eq "format") {
		my ($format,$engine,$pat,@rest) = split(",",$line);
		my $ret = "$format\t$engine\t$pat\t" . join(",",@rest);
		return($ret);
	} elsif ($type eq "language") {
		my ($lang,$pat,@rest) = split(",",$line);
		my $ret="$lang $pat\n";
		foreach (@rest) {
			$ret .= "=$_\n";
		}
		return($ret);
	}
}

#
# check wether a magic comment is already present
sub magic_comment_present {
	my ($fname) = @_;
	my @args = ( "grep", "-q", "^[#%] -_- DebPkgProvidedMaps -_-", $fname );
	if (system(@args) == 0) { return 1; }
	return 0;
}

#
#
# START OF THE MAIN PROGRAM
#
#

#
# parse the cmd line and fill in the various hashes
#
foreach (@ARGV) {
	if ((m/^(map)file=(.*\.cfg)(=([[:digit:]]+))?$/) ||
	    (m/^(language)file=(.*\.cnf)(=([[:digit:]]+))?$/) ||
	    (m/^(format)file=(.*\.cnf)(=([[:digit:]]+))?$/)) {
		my $type=$1;
		my $fn=$2;
		my $pr=$priority;
		if (defined($4)) {
			$pr=$4;
		}
		$cmdlinefilespriority{$type}{$fn}=$pr;
	} elsif (m/^(map|language|format)=(.*)$/) {
		push @{$cmdlineargs{$1}}, $2;
	} elsif (m/^texmftrees=(.*)$/) {
		@cmdlinetexmftrees = split /,/, $1;
	} else {
		error("Unrecognized argument: $_\n");
	}
}

#
#
if (defined($dh{FLAVOR})) {
	if ($dh{FLAVOR} eq "map:config_for_active_maps") {
		$mapdoconfig = 1;
	} elsif ($dh{FLAVOR} eq "map:config_for_all_maps") {
		$mapdoconfig = 2;
	} else {
		error("Specified flavor $dh{FLAVOR} not supported.\nPlease see man page for supported flavors!\n");
	}
}

if (defined($dh{PRIORITY}) && $dh{PRIORITY} ne '') {
	$priority=$dh{PRIORITY};
}


foreach my $package (@{$dh{DOPACKAGES}}) {
	# these variables should be local to the loop over packages
	# as they vary with package
	my $tmp=tmpdir($package);
	my %pkgprovidedfilecontents;
	my %data;
	my @whattodo = ();

	if (($package eq $dh{FIRSTPACKAGE} || $dh{PARAMS_ALL}) && @ARGV) {
		# we do nothing here
	} else {
		# we have to clear all the cmd line arguments!
		%cmdlinefilespriority = ();
		%cmdlineargs = ();
	}

	foreach my $type ("map", "language", "format") {
		my @cmdlineconfigfiles = ();
		my @cmdlinearguments = ();
		my $pkgprovidedfile = 0;
		my $pkgfileoncmdline = 0;
		my @listlines;
		my $pkgfilename = pkgfile($package,$pkgfileext{$type});
		if ($pkgfilename) {
			open(FOO, "<$pkgfilename") || error("$pkgfilename cannot be opened.");
			my @bar = <FOO>;
			close(FOO);
			$pkgprovidedfilecontents{$type} = \@bar;
			$pkgprovidedfile = 1;
		}
		if (defined($cmdlinefilespriority{$type})) {
			my %priorityhash = %{$cmdlinefilespriority{$type}};
			@cmdlineconfigfiles = keys(%priorityhash);
		}
		if (defined($cmdlineargs{$type})) {
			@cmdlinearguments = @{$cmdlineargs{$type}};
		}
		foreach my $foo (@cmdlineconfigfiles) {
			my $bn=basename($foo);
			if ($bn eq "$package.$configfileext{$type}" && $cmdlinefilespriority{$type}{$foo} == $priority) {
				$pkgfileoncmdline = 1;
			}
		}
		if (!$pkgprovidedfile && ($#cmdlineconfigfiles < 0) && ($#cmdlinearguments < 0)) {
			# we have nothing to do here, skip to the next one!
			next;
		}
		# we got something, either a cmd line are for one of the
		# config files, or a package (e.g., debian/pkg.maps) file 
		# do the full maintainer stuff!
		$dothefullstuff = 1;
		push @whattodo, $type;
		if ($pkgfileoncmdline && ($pkgprovidedfile || ($#cmdlinearguments >= 0))) {
			error("This call would create multiple copies of $priority$package.$configfileext{$_}.\nPlease read the man page on how this should be fixed!\n");
		}
        	if ( ! -d "$tmp/etc/texmf/$configdir{$type}/") {
			doit("install","-d","$tmp/etc/texmf/$configdir{$type}/");
        	}
		#
		# the cmd line cfg files
		#
		foreach (@cmdlineconfigfiles) {
			$bn=basename($_);
			$pr=$cmdlinefilespriority{$type}{$_};
			$dofilen = "$tmp/etc/texmf/$configdir{$type}/$pr$bn";
			-r $dofilen &&
				error("The config file $dofilen already exists! Cannot recreate it, please call dh_clean -k!");
			open(CFGFILE, ">$dofilen") ||
				error("Cannot open $dofilen for writing!");
			verbose_print("Writing $dofilen");
			if (!magic_comment_present($_)) {
				print CFGFILE "$commentchar{$type} $pr$bn\n";
				foreach $i (@magicheader) {
					print CFGFILE "$commentchar{$type} $i\n";
				}
			}
			open(FOO,"<$_") || error("Cannot open $_ for reading!");
			while (<FOO>) { 
				print CFGFILE $_; 
				collect_data($type,\@{$data{$type}},$_);
			}
			close(FOO);
			close(CFGFILE);
			$bn =~ s/\.$configfileext{$type}$//;
			push @listlines, "$pr$bn";
		}
		#
		# now debian/package.maps and/or debian/maps formats languages
		# merge in the cmd line arguments
		#
		if ($pkgprovidedfile || ($#cmdlinearguments >= 0)) {
			$dofilen = "$tmp/etc/texmf/$configdir{$type}/$priority$package.$configfileext{$type}";
			-r $dofilen && 
				error("The config file $dofilen already exists! Cannot recreate it, please call dh_clean -k!");
			open(CFGFILE, ">$dofilen") || 
				error("Cannot open $dofilen for writing!");
			verbose_print("Writing $dofilen");
			if (($pkgprovidedfile && !magic_comment_present($pkgfilename)) ||
		    	    (!$pkgprovidedfile && ($#cmdlinearguments >= 0))) {
				print CFGFILE "$commentchar{$type} $priority$package.$configfileext{$type}\n";
				foreach (@magicheader) {
					print CFGFILE "$commentchar{$type} $_\n";
				}
			}
			foreach (@{$pkgprovidedfilecontents{$type}}) {
				print CFGFILE "$_";
				collect_data($type,\@{$data{$type}},$_);
			}
			foreach (@cmdlinearguments) {
				my $foo =  build_line($type,$_);
				print CFGFILE $foo,"\n";
				collect_data($type,\@{$data{$type}},$foo);
			}
			close(CFGFILE);
			push @listlines, "$priority$package";
		}
		
        	if ( ! -d "$tmp/var/lib/tex-common/$managedir{$type}/") {
            		doit("install","-d","$tmp/var/lib/tex-common/$managedir{$type}/");
        	}
		$dofilen = "$tmp/var/lib/tex-common/$managedir{$type}/$package.list";
		open(LISTFILE, ">>$dofilen")||
			error("Cannot open $dofilen for writing/appending!");
		verbose_print("Writing $dofilen");
		foreach (@listlines) {
			print LISTFILE "$_\n";
		}
		close(LISTFILE);

		if ($type eq "map") {
		    my @data = @{$data{"map"}};
		    if ($#data >= 0) {
			doit("install","-d","$tmp/usr/share/texmf/dvips/config/");
		    }
		    foreach $i (@data) {
			my $f = $i;
			$f =~ s/\.map$//;
			$dofilen = "$tmp/usr/share/texmf/dvips/config/config.$f";
			-r $dofilen &&
			    error("The dvips config file $dofilen already exists!\nYou may have to call dh_clean -k!\n");
			open(CNFFILE, ">$dofilen") ||
			    error("Cannot open $dofilen for writing!");
			verbose_print("Writing $dofilen");
			print CNFFILE "p +$i\n";
			close(CNFFILE);
		    }
		}
	}

	my @fmtdata = ();
	if (defined($data{"format"})) {
		@fmtdata = @{$data{"format"}};
	}
	if (! $dh{NOSCRIPTS}) {
		my %uniq;
		foreach (@cmdlinetexmftrees, @defaulttexmftrees) { 
			$uniq{$_} = 1; 
		}
		my @foo = keys(%uniq);
		autoscript($package, "postinst", "postinst-texlsr", "s|#TEXMFTREES#|@foo|");
		autoscript($package, "postrm",   "postrm-texlsr", "s|#TEXMFTREES#|@foo|");
		if ($dothefullstuff) {
			autoscript($package, "postinst", "postinst-tex", "s/#FORMATS#/@fmtdata/; s/#WHATTODO#/@whattodo/");
			autoscript($package, "postrm",   "postrm-tex", "s/#FORMATS#/@fmtdata/; s/#WHATTODO#/@whattodo/");
		}
	}

	addsubstvar($package, "misc:Depends", "tex-common", ">= 0.7");
}

=head1 SEE ALSO

L<debhelper(7)>

=head1 AUTHOR

Norbert Preining <preining@logic.at>

=cut
