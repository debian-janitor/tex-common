#!/usr/bin/perl
# update-hyphen --- Generate language.dat* from a set of files
# Copyright (C) 2015 Norbert Preining
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 dated June, 1991.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING. If not, write to the
# Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
# Boston, MA  02110-1301 USA.


$^W = 1;
use strict;

my $version = "0.1";

BEGIN {
  unshift (@INC, "/usr/share/texlive/tlpkg");
}

use TeXLive::TLUtils;
use File::Basename;
use Getopt::Long;

my $shortdesc = 'Generate hyphenation configuration files language.dat, .def, .dat.lua';
my $mode = 'all';

# for each file in /var/lib/tex-common/hyphen-cnf/
# plus the config file /etc/texmf/web2c/local-hyphen.cnf

my $localconf = '/etc/texmf/web2c/local-hyphen.cnf';
my $default_output_dir = '/var/lib/texmf/tex/generic/config';
my %data;
my $progname = basename($0);

my $opt_conf_file = "";
my $opt_output    = "";
my $opt_outdir    = "";
my $opt_checks = 0;
my $opt_quiet  = 0;
my $opt_help   = 0;
my $opt_version = 0;

my %defaults = (
  'latex' => {
    'output' => 'language.dat',
    'func'   => \&make_latex_line,
    'desc'   => 'Generate language.dat, the hyphenation configuration file for LaTeX',
    'head'   => '/usr/share/texlive/texmf-dist/tex/generic/config/language.us',
    'post'   => '',
  },
  'etex' => {
    'output' => 'language.def',
    'func'   => \&make_etex_line,
    'desc'   => 'Generate language.def, the hyphenation configuration file for eTeX and friends',
    'head'   => '/usr/share/texlive/texmf-dist/tex/generic/config/language.us.def',
    'post'   => "\n\\uselanguage \{USenglish\}  \%\%\% This MUST be the last line of the file.\n",
  },
  'luatex' => {
    'output' => 'language.dat.lua',
    'func'   => \&make_luatex_line,
    'desc'   => 'Generate language.dat.lua, the hyphenation configuration file for luaTeX and friends',
    'head'   => '/usr/share/texlive/texmf-dist/tex/generic/config/language.us.lua',
    'post'   => "\}\n",
  }
);

&main();

# from here on only sub definitions!

sub main {
  setup_caller();

  GetOptions(
    "conf-file|c=s"     => \$opt_conf_file,
    "output-file|o=s"   => \$opt_output,
    "output-dir|d=s"    => \$opt_outdir,
    "checks"            => \$opt_checks,
    "quiet|q"           => \$opt_quiet,
    "help|h|?"          => \$opt_help,
    "version|v"         => \$opt_version) or usage();

  if ($opt_help) {
    usage();
    exit 0;
  }

  if ($opt_version) {
    version();
    exit 0;
  }

  update_conffiles($mode);
}


sub update_conffiles {
  my $mode = shift;
  my @todo;

  if ($mode eq 'all') {
    push @todo, keys(%defaults);
  } else {
    push @todo, $mode;
  }

  read_data();

  for my $t (@todo) {
    my $of = ($opt_output ? $opt_output : 
      ( $opt_outdir ? "$opt_outdir/$defaults{$t}{'output'}" :
        "$default_output_dir/$defaults{$t}{'output'}"));
    print "writing to $of!\n";
    open(FOO, ">$of") || die "Cannot open $of: $!";

    if (-r $defaults{$t}{'head'}) {
      open BAR, "<", $defaults{$t}{'head'} || die("Cannot open head file $defaults{$t}{'head'}: $!");

      for (<BAR>) { print FOO $_; }
      close BAR;
    } else {
      die("Missing head file $defaults{$t}{'head'}: $!");
    }
    for my $n (keys %data) {
      print FOO &{$defaults{$t}{'func'}}($n);
    }
    print FOO $defaults{$t}{'post'};
    close FOO;
  }
}

# should have been in TLUtils, but the actual code is hidden
# in TLPOBJ.pm, bad!
sub make_latex_line {
  my $n = shift;
  my $ret = "$n " . $data{$n}{'file'} . "\n";
  if ($data{$n}{'synonyms'}) {
    for my $s (@{$data{$n}{'synonyms'}}) {
      $ret .= "=$s\n";
    }
  }
  return $ret;
}
sub make_etex_line {
  my $n = shift;
  my $file = $data{$n}{'file'};
  my $lhm  = $data{$n}{'lefthyphenmin'};
  my $rhm  = $data{$n}{'righthyphenmin'};
  my $ret = "\\addlanguage\{$n\}\{$file\}\{\}\{$lhm\}\{$rhm\}\n";
  return $ret;
}
sub make_luatex_line {
  my $n = shift;
  my $file = $data{$n}{'file'};
  my $exc  = $data{$n}{'file_exceptions'};
  my $lhm  = $data{$n}{'lefthyphenmin'};
  my $rhm  = $data{$n}{'righthyphenmin'};
  my $patt = $data{$n}{'file_patterns'};
  my $special = $data{$n}{'luaspecial'};
  my $syns = '';
  if ($data{$n}{'synonyms'}) {
    my @syn = (@{$data{$n}{'synonyms'}});
    map { $_ = "'$_'" } @syn;
    $syns = join(', ', @syn);
  }
  my $ret = <<"EOF"
  [\'$n\'] = {
    loader = \'$file\',
    lefthyphenmin = $lhm,
    righthyphenmin = $rhm,
    synonyms = { $syns },
EOF
  ;
  $ret .= "    patterns = \'$patt\',\n" if defined $patt;
  $ret .= "    hyphenation = \'$exc\',\n" if defined $exc;
  $ret .= "    special = \'$special\',\n" if defined $special;
  $ret .= "  },\n";
  return $ret;
}


sub read_one_file {
  my $f = shift;
  my $do_warn = shift;
  open FOO, "<$f" || die ("Cannot read file $f: $!");
  while (<FOO>) {
    next if /^\s*%/;
    next if /^\s*$/;
    my %r = TeXLive::TLUtils::parse_AddHyphen_line($_);
    if (defined($r{"error"})) {
      die ("Cannot parse $_ in $f: $r{'error'}");
    }
    my $n = $r{'name'};
    if ($do_warn && defined($data{$n})) {
      printf STDERR "double defined hyphenations pattern found: $n\n";
    }
    for my $k (keys %r) {
      next if ($k eq "name");
      $data{$n}{$k} = $r{$k};
    }
  }
  close FOO;
}

sub read_data {
  if (-d '/var/lib/tex-common/hyphen-cnf/') {
    for my $f (</var/lib/tex-common/hyphen-cnf/*.cnf>) {
      read_one_file($f, 1);
    }
  }
  if (-r $localconf) {
    read_one_file($localconf, 0);
  }
}

sub setup_caller {
  if ($progname eq "update-language") {
    $mode = "all";
  } elsif ($progname eq "update-language-dat") {
    $mode = "latex";
  } elsif ($progname eq "update-language-def") {
    $mode = "etex";
  } elsif ($progname eq "update-language-lua") {
    $mode = "luatex";
  } else {
    die "Please call me as update-language(-dat,-def,-lua).";
  }
}

sub version {
  print "$progname $version\n";
}

sub usage () {
  version();
  if ($mode eq "all") {
    print <<"EOF"
Usage: $progname
$shortdesc

Calls the programs update-language-dat, update-language-def, and
update-language-lua without any additional arguments.
EOF
;
  } else {
    print <<"EOF"

Usage: $progname [OPTION ...]
$defaults{$mode}{'desc'}

Options:
  -c, --conf-file=FILE   file giving additional hyphen specifications
                         ($localconf)
  -o, --output-file=FILE file to write the output to
                         ($opt_output)
      --checks           perform sanity checks on the generated config file
  -q, --quiet            don't write anything to the standard output during
                         normal operation
  -h, -?, --help         display this help message and exit
      --version          output version information and exit
EOF
;
  }
}

### Local Variables:
### perl-indent-level: 2
### tab-width: 2
### indent-tabs-mode: nil
### End:
# vim:set tabstop=2 expandtab: #
