#include variables
#!/bin/sh -e
# 
# config maintainer script for the Debian <:=${PACKAGE}:> package.
# $Id: config.in 114 2005-08-04 15:04:01Z frn $
<:=@COPYRIGHT:>//

# Give names to the commandline arguments
action=$1
installed_version=$2

# common variables
FONTCACHE_PERMS=<:=$FONTCACHE_PERMS:>



. <:=${CONFMODULE}:>
db_version 2.0

<:open(FUNCTIONS,'common.functions');@FUNCTIONS=<FUNCTIONS>;close(FUNCTIONS):>//
<:=@FUNCTIONS:>//

## do the things we have to do for upgraders from old versions
# it does not harm to do the checks also when $action is reconfigure.

# suggest a user to rename old cnf files (copyright Atsuhito?)
# (upgrade from woody, keep for etch?)
if [ -d /etc/texmf/texmf.d ]; then
    if ls /etc/texmf/texmf.d 2> /dev/null | egrep -vq '(\.cnf|\.dpkg-.*|~)$'; then
	db_input medium tex-common/cnf_name || true
	db_go || true
    fi
fi


# we also unregister the tetex-bin/lsr-perms
db_unregister tetex-bin/lsr-perms || true

# and unregister old tex-common questions, they are not needed anymore
db_unregister tex-common/groupperm || true
db_unregister tex-common/userperm || true
db_unregister tex-common/managedlsr || true

# The groupname question has been split up, but it need not be shown again
db_fget tex-common/groupname seen || true
if [ "$RET" = true ]; then
 db_fset tex-common/groupname_single seen true || true
 db_fset tex-common/groupname_multi seen true || true
fi
db_unregister tex-common/groupname


# this script may be run twice: Once by dpkg-preconfigure, once again by
# debconf when it is sourced in the postinst script.  We must do the
# following only once, therefore we fiddle with a special flag
db_fget tex-common/managecache firstrundone || true

if [ "$RET" != "true" ]; then
  # we are in the first pass, set the flag and do the things
  db_fset tex-common/managecache firstrundone true

  # check wether the directory /var/cache/fonts is group writeable and
  # for which group
  PERMS=$(stat --format="%a" /var/cache/fonts 2>/dev/null) || true
  GROUP=$(stat --format="%G" /var/cache/fonts 2>/dev/null) || true

  if [ "$GROUP" = "UNKNOWN" ] ; then
    GROUP=$(stat --format="%g" /var/cache/fonts 2>/dev/null) || true
  fi

  # see wether we already have asked this question once
  db_fget tex-common/managecache seen || true
  SEEN="$RET"

  if [ "$SEEN" = true ] ; then
    # this question was already shown
    # if the permissions are still <:=$FONTCACHE_PERMS:> we set managecache to true
    if [ "$PERMS" = $FONTCACHE_PERMS ] ; then
      db_set tex-common/managecache true || true
      db_set tex-common/groupname_single "$GROUP" || true
      db_set tex-common/groupname_multi "$GROUP" || true
    else
      db_set tex-common/managecache false || true
    fi
  else
    # this question has not been seen, so if the permissions are 
    # - either the new permissions <:=$FONTCACHE_PERMS:> as we'd like to set them
    # - or the permissions as shipped by old tetex versions
    # then set the managecache to true, otherwise to false
    # we will later change it to <:=$FONTCACHE_PERMS:> in the true case
    #
    # If the permissions are empty (preconfigure phase) or as shipped
    # in the deb, don't set to true (after noninteractive install in
    # pbuilder etc., dir needs to be world-writable).

    if [ "$PERMS" = $FONTCACHE_PERMS ] || [ "$PERMS" = 1777 ]; then
      db_set tex-common/managecache true || true
    else
      db_set tex-common/managecache false || true
    fi
  fi

  # now check whether this machine has only one normal user account (outside the system range)
  usercount=0
  userid=""
  for uid in `getent passwd | cut -d ':' -f 3`; do
    if [ $uid -ge 1000 ] && [ $uid -le 29999 ]; then
      userid=$uid
      : $(($usercount+1))
    fi
  done
  if [ $usercount -eq 1 ]; then
    db_set tex-common/singleuser true
    # exactly one user account, number in $userid: suggest its group
    groupID=`getent passwd | egrep "^[^:]+:[^:]+:$userid:" | cut -d ':' -f 4`
    GROUP=`getent group | egrep "^[^:]+:[^:]+:$groupID:" | cut -d ':' -f 1`
    db_set tex-common/groupname_single "$GROUP" || true
  fi

  cache_debconf_priority=medium
  db_input $cache_debconf_priority tex-common/managecache || true
  db_go

  db_get tex-common/managecache || true
  if [ "$RET" = true ]; then
    groupname_variant=multi
    if [ $usercount -eq 1 ]; then
      groupname_variant=single
    fi
    while true; do
      db_input $cache_debconf_priority tex-common/groupname_$groupname_variant || true
      db_go || true
      db_get tex-common/groupname_$groupname_variant || true
      GROUP="$RET"
      # now check whether the returned group name exists.  This time, we can't rely on
      # /etc/group, since we would never get out of this loop if the group information
      # comes from somewhere else.
      # Instead, we try to chown a file to that group
      dobreak=true # means: execute /bin/true, do not break out of the loop
      tempfile=`mktemp`
      if [ -n "$GROUP" ] && chown :$GROUP $tempfile; then # no redirecting of stderr!
	dobreak=break
      fi
      $dobreak
      # still there?  invalid group
      db_subst tex-common/invalid_groupname badgroup $GROUP || true
      db_input $cache_debconf_priority tex-common/invalid_groupname || true
      db_go
    done
  fi
fi

# Local Variables:
# mode: shell-script
# skeleton-pair: t
# End:

