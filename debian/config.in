#include variables
#!/bin/sh -e
# 
# config maintainer script for the Debian <:=${PACKAGE}:> package.
# $Id: config.in 114 2005-08-04 15:04:01Z frn $
<:=@COPYRIGHT:>//

# Give names to the commandline arguments
action=$1
installed_version=$2


. <:=${CONFMODULE}:>
db_version 2.0

<:open(FUNCTIONS,'common.functions');@FUNCTIONS=<FUNCTIONS>;close(FUNCTIONS):>//
<:=@FUNCTIONS:>//

## do the things we have to do for upgraders from old versions
# it does not harm to do the checks also when $action is reconfigure.

# suggest a user to rename old cnf files (copyright Atsuhito?)
# (upgrade from woody, keep for etch?)
if [ -d /etc/texmf/texmf.d ]; then
    if ls /etc/texmf/texmf.d 2> /dev/null | egrep -vq '(\.cnf|\.dpkg-.*|~)$'; then
	db_input medium tex-common/cnf_name || true
	db_go || true
    fi
fi


# we also unregister the tetex-bin/lsr-perms
db_unregister tetex-bin/lsr-perms || true

# and unregister old tex-common questions, they are not needed anymore
db_unregister tex-common/groupperm || true
db_unregister tex-common/userperm || true


#
# first we collect those ls-R files which are group writeable in gwritetrue
# and those which are not group writeable in gwritefalse
# furthermore we save the respective group and write permission in
# ${i}group
gwritetrue=""
gwritefalse=""
lsrfile_exists=""
for i in var cache main ; do
    eval \$${i}group=""
    lsr=`select_lsrfile $i`
    if [ -r $lsr ] ; then
        lsrfile_exists="true"
    	tmp=`ls -l $lsr | awk '{print$4}'`
	eval \$${i}group=$tmp
	if ls -l $lsr | grep -q ^.....w ; then
	    gwritetrue="$gwritetrue $i"
	else
	    gwritefalse="$gwritefalse $i"
	fi
    fi
done
#
# now we save the list of group writeable ls-R files to tex-common/managedlsr
# (but only if we found any.  On a fresh install, we'll show the default.')
if [ "$lsrfile_exists" = "true" ]; then
    db_set tex-common/managedlsr $gwritetrue || true
fi
#
# and ask the user to check if this selection is ok
db_input low tex-common/managedlsr || true
db_go

#
# get the answer of the users, ie what files should really be group writeable
db_get tex-common/managedlsr && SELECTED_LSR="$RET" || true
if [ -n "$SELECTED_LSR" ]; then
    #
    # we check wether all the group writeable files belong to the same group.
    # if yes, we suggest this group and ask the groupname question,
    # otherwise we ignore this and do *not* play around with groups.
    iscommongroup=-1
    for i in $SELECTED_LSR ; do
      eval tmp=\$${i}group
      if [ "X$iscommongroup" = "X-1" ] ; then
	 iscommongroup=$tmp
      else
         if [ ! $tmp = $iscommongroup ] ; then
	    iscommongroup=""
	 fi
      fi
    done
    db_set tex-common/groupname "$iscommongroup" || true
    if [ -n $iscommongroup ] ; then
      #
      # here we could be more intelligent and check wether the choosen group
      # actually exist, and if not, reask again!
      #
      db_input low tex-common/groupname || true
      db_go
    fi
fi
#
# we do not care for user permissions in this setting!
#

# Local Variables:
# mode: shell-script
# skeleton-pair: t
# End:

